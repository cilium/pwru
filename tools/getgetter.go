// SPDX-License-Identifier: GPL-2.0-only
// Copyright (C) 2022 Authors of Cilium

// This tool parses the provided Go files to generate getters for any exported
// fields of each struct matching the struct regexp filter.

package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/ast"
	"go/build/constraint"
	"go/parser"
	"go/printer"
	"go/token"
	"log"
	"os"
	"path/filepath"
	"regexp"
	"strings"
	"text/template"

	"golang.org/x/tools/imports"
)

type Comment string

type Struct struct {
	Name      string
	ShortName string
	Fields    []Field
}

type Field struct {
	Name string
	Type string
}

type File struct {
	FileName         string
	PackageName      string
	BuildConstraints []Comment
	Structs          []Struct
}

const fileTemplate = `// Code generated by getgetter; DO NOT EDIT.
{{- range .BuildConstraints }}
{{ . }}
{{- end }}

package {{.PackageName}}

{{- range .Structs }}
{{ $struct := . }}
  {{- range .Fields }}
func ({{ $struct.ShortName }} *{{ $struct.Name }}) Get{{ .Name }}(   ) {{ .Type }} {
	return {{ $struct.ShortName }}.{{ .Name }}
}
  {{- end }}
{{- end }}
`

func (f *File) generateGetterFile() error {
	if len(f.Structs) == 0 {
		return nil
	}

	// Generate getters based on above template
	var buf bytes.Buffer
	tmpl := template.New("")
	tmpl, err := tmpl.Parse(fileTemplate)
	if err != nil {
		return err
	}
	err = tmpl.Execute(&buf, f)
	if err != nil {
		return fmt.Errorf("failed to populate template for file %q: %w", f.FileName, err)
	}

	// Fix up any missing imports for external types and format the code
	ext := filepath.Ext(f.FileName)
	fileName := f.FileName[:len(f.FileName)-len(ext)] + "_getter" + ext
	formatted, err := imports.Process(fileName, buf.Bytes(), nil)
	if err != nil {
		return fmt.Errorf("failed to format source code for file %q: %w", f.FileName, err)
	}

	// Write generated file to disk
	err = os.WriteFile(fileName, formatted, 0666)
	if err != nil {
		return fmt.Errorf("failed write generated file %q: %w", fileName, err)
	}

	fmt.Printf("Wrote %s\n", fileName)

	return nil
}

func extractStructsFromFile(fset *token.FileSet, fileName string, structFilter func(string) bool) (File, error) {
	file, err := parser.ParseFile(fset, fileName, nil, parser.ParseComments)
	if err != nil {
		return File{}, err
	}

	f := File{
		FileName:    fileName,
		PackageName: file.Name.String(),
	}

	// collect build constraints
	for _, group := range file.Comments {
		for _, comment := range group.List {
			c := comment.Text
			if constraint.IsGoBuild(c) || constraint.IsPlusBuild(c) {
				f.BuildConstraints = append(f.BuildConstraints, Comment(c))
			}
		}
	}

	ast.Inspect(file, func(n ast.Node) bool {
		// stop inspecting if an error occurred
		if err != nil {
			return false
		}

		switch x := n.(type) {
		case *ast.TypeSpec: // type x foo
			st, ok := x.Type.(*ast.StructType) // struct
			if !ok {
				return false // not a struct
			}

			structName := x.Name.Name
			if len(structName) == 0 || !structFilter(structName) {
				return false // not interested in this struct
			}

			// extract struct fields and their type
			fields := make([]Field, 0, st.Fields.NumFields())
			for _, field := range st.Fields.List {
				for _, name := range field.Names {
					var typeNameBuf bytes.Buffer
					err = printer.Fprint(&typeNameBuf, fset, field.Type)
					if err != nil {
						return false
					}
					typeName := typeNameBuf.String()
					if len(name.Name) == 0 || len(typeName) == 0 {
						continue
					}

					if ast.IsExported(name.Name) {
						fields = append(fields, Field{
							Name: name.Name,
							Type: typeName,
						})
					}
				}
			}

			f.Structs = append(f.Structs, Struct{
				Name:      structName,
				ShortName: strings.ToLower(structName)[0:1],
				Fields:    fields,
			})
			return false
		}
		return true
	})
	if err != nil {
		return File{}, err
	}

	return f, nil
}

func main() {
	var inputGlob, structRegexp string
	flag.StringVar(&inputGlob, "input", "*.go", "glob pattern of files to generate getters for")
	flag.StringVar(&structRegexp, "struct", "", "generate getters for structs matching this regexp (required)")
	flag.Parse()

	if structRegexp == "" {
		flag.Usage()
		return
	}

	sourceFiles, err := filepath.Glob(inputGlob)
	if err != nil {
		log.Fatalf("failed to read source files: %s", err)
	}

	structFilter, err := regexp.Compile(structRegexp)
	if err != nil {
		log.Fatalf("failed parse -struct filter: %s", err)
	}

	fset := token.NewFileSet()
	for _, fileName := range sourceFiles {
		f, err := extractStructsFromFile(fset, fileName, structFilter.MatchString)
		if err != nil {
			log.Fatalf("failed parse file %q: %s", fileName, err)
		}

		err = f.generateGetterFile()
		if err != nil {
			log.Fatalf("failed generate getters file for %q: %s", fileName, err)
		}
	}
}
